import os
import json
import asyncio
import time
from typing import List
from fastapi import APIRouter, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from dotenv import load_dotenv
from agents import Agent, function_tool, Runner, AsyncOpenAI, OpenAIChatCompletionsModel
from agents.run import RunConfig
import httpx
from weasyprint import HTML
from datetime import datetime
import markdown2

# Load env if needed
load_dotenv()

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "AIzaSyAcnP2ggQFQMGZe8WwZsGdk4ckGwc05RL0")

router = APIRouter(prefix="/recon", tags=["Recon Agent"])

# ✅ Pydantic models
class Finding(BaseModel):
    plugin: str
    description: str
    severity: str
    cve_ids: List[str] = []

class ScanAnalysis(BaseModel):
    host: str
    findings: List[Finding]
    summary: str

# ✅ Helper function tool
@function_tool
def load_scan(json_str: str) -> dict:
    return json.loads(json_str)

# ✅ PDF generator using WeasyPrint
def generate_pdf(report_text: str, output_path: str):
    html_body = markdown2.markdown(report_text)

    title_page_html = f"""
    <html><head><style>
    @page {{ size: A4; margin: 0; }}
    body {{ font-family: 'Segoe UI', sans-serif; text-align: center; padding-top: 200px; background-color: #fdfdfd; color: #222; }}
    .title {{ font-size: 40px; font-weight: bold; margin-bottom: 20px; color: #0057b7; }}
    .subtitle {{ font-size: 20px; color: #777; margin-bottom: 40px; }}
    .footer {{ position: absolute; bottom: 60px; width: 100%; text-align: center; font-size: 14px; color: #999; }}
    </style></head><body>
        <div class="title">Security Assessment Report</div>
        <div class="subtitle">Generated by Rconsense</div>
        <div class="subtitle">Date: {datetime.now().strftime('%Y-%m-%d')}</div>
        <div class="footer">Rconsense AI Security Analysis Engine</div>
    </body></html>
    """

    report_content_html = f"""
    <html><head><meta charset="utf-8">
    <style>
    body {{ font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; margin: 40px; color: #333; line-height: 1.6; }}
    h1, h2, h3 {{ color: #0057b7; }}
    .footer {{ margin-top: 50px; font-size: 0.9em; color: #777; text-align: center; border-top: 1px solid #ddd; padding-top: 10px; }}
    .header {{ text-align: center; border-bottom: 2px solid #0057b7; padding-bottom: 10px; margin-bottom: 30px; }}
    .header h1 {{ margin: 0; font-size: 2em; }}
    .header .sub {{ font-size: 1em; color: #666; }}
    </style></head><body>
        <div class="header">
            <h1>Executive Summary & Technical Analysis</h1>
            <div class="sub">Confidential – Internal Use Only</div>
        </div>
        {html_body}
        <div class="footer">Report automatically generated by Rconsense</div>
    </body></html>
    """

    combined_html = f"""
    <html><body>
        <div>{title_page_html}</div>
        <div style="page-break-after: always;"></div>
        <div>{report_content_html}</div>
    </body></html>
    """

    HTML(string=combined_html).write_pdf(output_path)

# ✅ Gemini-compatible client (AsyncOpenAI stub - not used here but retained for compatibility)
external_client = AsyncOpenAI(
    api_key=GEMINI_API_KEY,
    base_url="https://generativelanguage.googleapis.com/v1beta/"
)

async def call_gemini(prompt: str) -> str:
    url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"
    headers = {"Content-Type": "application/json"}
    params = {"key": GEMINI_API_KEY}
    payload = { "contents": [ { "parts": [ { "text": prompt } ] } ] }

    async with httpx.AsyncClient(timeout=20) as client:
        try:
            response = await client.post(url, headers=headers, params=params, json=payload)
            response.raise_for_status()
            return response.json()["candidates"][0]["content"]["parts"][0]["text"]
        except httpx.HTTPStatusError as exc:
            raise HTTPException(status_code=exc.response.status_code, detail=f"Gemini API error: {exc.response.text}")
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Unexpected error: {repr(e)}")

# ✅ API Endpoint
@router.post("/analyze-scan")
async def analyze_scan(file: UploadFile = File(...)):
    if file.content_type != "application/json":
        raise HTTPException(status_code=400, detail="Only JSON files are supported.")

    try:
        scan_json_str = (await file.read()).decode("utf-8")
        scan_data = json.loads(scan_json_str)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to decode file: {e}")

    # Split data into chunks if needed
    if isinstance(scan_data, list):
        chunks = [scan_data[i:i + 5] for i in range(0, len(scan_data), 5)]
    elif isinstance(scan_data, dict) and "findings" in scan_data:
        findings = scan_data["findings"]
        chunks = [findings[i:i + 5] for i in range(0, len(findings), 5)]
    else:
        chunks = [scan_data]

    all_responses = []
    prompt_base = """
You are an AI security analyst. You will receive a JSON scan result via the `load_scan` tool.
Your goal is to provide a comprehensive and visually engaging security report.

You must:

1. Write a **professional 5-page style report** based only on the available data in the scan.
2. Include the following sections:
   - Executive Summary
   - Technical Analysis (with references to actual JSON data)
   - Vulnerabilities (with severity, evidence, CVE if applicable)
   - Recommendations (technical, organizational, and future work)
   - Inferred Risks and Business Impact
3. Mention specific data from the scan like domains, IPs, open ports, OS, DNS results, etc.
4. Even if the scan is partial or limited, make the best analysis possible using inference and known attack patterns.
5. The report should be **complete and final** – do not suggest a “Part 2” or defer work to the future.
6. Structure it to be directly usable in a PDF report generator.
7. Prioritize clarity, technical accuracy, and a formal tone.
"""

    for idx, chunk in enumerate(chunks):
        chunk_str = json.dumps(chunk, indent=2)
        try:
            response = await call_gemini(prompt_base + "\n\nScan Data:\n" + chunk_str)
            all_responses.append(response)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Gemini call failed on chunk {idx+1}: {str(e)}")

    full_report = "\n\n".join(all_responses)
    pdf_output_path = f"/tmp/report_{int(time.time())}.pdf"
    generate_pdf(full_report, pdf_output_path)

    return JSONResponse(content={"summary": full_report})

# POST endpoint to analyze uploaded scan JSON
# @router.post("/analyze-scan", response_model=ScanAnalysis)
# async def analyze_scan(file: UploadFile = File(...)):
#     if file.content_type != "application/json":
#         raise HTTPException(status_code=400, detail="Only JSON files are supported.")

#     try:
#         scan_json_str = (await file.read()).decode("utf-8")
#     except Exception as e:
#         raise HTTPException(status_code=400, detail=f"Failed to decode file: {e}")

#     # Configure model and agent run setup
#     model = OpenAIChatCompletionsModel(
#         model="gemini-1.5-flash",  # Gemini-compatible model
#         openai_client=external_client
#     )

#     run_config = RunConfig(
#         model=model,
#         model_provider=external_client,
#         tracing_disabled=True
#     )

#     agent = Agent(
#     name="Security Recon Agent",
#     instructions=(
#         "You are an AI security analyst. You will receive a JSON scan result via the `load_scan` tool. "
#         "Your goal is to provide a comprehensive and visually engaging security report. "
#         "Include detailed insights such as scanned hosts, identified vulnerabilities, plugins used, descriptions, severity levels, and CVE IDs. "
#         "Even if the input data is limited, infer and highlight potential vulnerabilities, weak points, or misconfigurations. "
#         "Be sure to include any suspected parameters, common attack vectors, and best-practice gaps. "
#         "Summarize your findings with clear, actionable insights, and rate the overall security posture of the scanned entity. "
#         "Your output will be converted into a professional report, so prioritize clarity, depth, and presentation quality."
#     ),
#     tools=[load_scan],
#     output_type=ScanAnalysis,
#     model=model
# )

#     try:
#         result = await Runner.run(agent, input=scan_json_str, run_config=run_config)
#     except Exception as e:
#         raise HTTPException(status_code=500, detail=f"Agent processing failed: {str(e)}")

#     if not result.final_output:
#         raise HTTPException(status_code=500, detail="Agent did not return output")

#     return result.final_output